// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace Cluster {
    export interface ClusterQueueHostedAgents {
        /**
         * The instance shape to use for the Hosted Agent cluster queue. This can be a MacOS instance shape or a Linux instance shape.
         * Valid values are:
         * - MACOS_ARM64_M4_6X28
         * - MACOS_ARM64_M4_12X56
         * - LINUX_AMD64_2X4
         * - LINUX_AMD64_4X16
         * - LINUX_AMD64_8X32
         * - LINUX_AMD64_16X64
         * - LINUX_ARM64_2X4
         * - LINUX_ARM64_4X16
         * - LINUX_ARM64_8X32
         * - LINUX_ARM64_16X64
         */
        instanceShape: string;
        linux?: outputs.Cluster.ClusterQueueHostedAgentsLinux;
        mac?: outputs.Cluster.ClusterQueueHostedAgentsMac;
    }

    export interface ClusterQueueHostedAgentsLinux {
        /**
         * A URL reference to a container image that will be used for jobs running within the queue. This URL is required to be publicly available, or pushed to the internal registry available within the cluster. Please note that this value is currently experimental and in preview. Please contact support@buildkite.com to enable this functionality for your organization.
         */
        agentImageRef: string;
    }

    export interface ClusterQueueHostedAgentsMac {
        /**
         * Optional selection of a specific macOS version to be selected for jobs in the queue to have available. Please note that this value is currently experimental and may not function as expected.
         */
        macosVersion?: string;
        /**
         * Required selection of a specific XCode version to be selected for jobs in the queue to have available. Please note that this value is currently experimental and may not function as expected.
         */
        xcodeVersion: string;
    }

    export interface GetClusterMaintainer {
        /**
         * The email of the actor (only for users).
         */
        actorEmail: string;
        /**
         * The name of the actor.
         */
        actorName: string;
        /**
         * The slug of the actor (only for teams).
         */
        actorSlug: string;
        /**
         * The type of the actor (user or team).
         */
        actorType: string;
        /**
         * The UUID of the actor (user or team).
         */
        actorUuid: string;
        /**
         * The UUID of the maintainer permission.
         */
        permissionUuid: string;
    }

    export interface GetClustersCluster {
        /**
         * The color for the cluster.
         */
        color: string;
        /**
         * The default queue for the cluster.
         */
        defaultQueue: outputs.Cluster.GetClustersClusterDefaultQueue;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * The emoji for the cluster.
         */
        emoji: string;
        /**
         * The GraphQL ID of the cluster.
         */
        id: string;
        /**
         * List of maintainers (users and teams) for this cluster.
         */
        maintainers: outputs.Cluster.GetClustersClusterMaintainer[];
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * The UUID of the cluster.
         */
        uuid: string;
    }

    export interface GetClustersClusterDefaultQueue {
        /**
         * The description of the default queue.
         */
        description: string;
        /**
         * The GraphQL ID of the default queue.
         */
        id: string;
        /**
         * The key of the default queue.
         */
        key: string;
        /**
         * The UUID of the default queue.
         */
        uuid: string;
    }

    export interface GetClustersClusterMaintainer {
        /**
         * The email of the actor (only for users).
         */
        actorEmail: string;
        /**
         * The name of the actor.
         */
        actorName: string;
        /**
         * The slug of the actor (only for teams).
         */
        actorSlug: string;
        /**
         * The type of the actor (user or team).
         */
        actorType: string;
        /**
         * The UUID of the actor (user or team).
         */
        actorUuid: string;
        /**
         * The UUID of the maintainer permission.
         */
        permissionUuid: string;
    }

}

export namespace Organization {
    export interface GetMembersMember {
        /**
         * The email address of the organization member.
         */
        email: string;
        /**
         * The GraphQL ID of the organization member.
         */
        id: string;
        /**
         * The name of the organization member.
         */
        name: string;
        /**
         * The UUID of the organization member.
         */
        uuid: string;
    }

    export interface GetPortalCreatedBy {
        /**
         * The email of the user.
         */
        email: string;
        /**
         * The name of the user.
         */
        name: string;
        /**
         * The UUID of the user.
         */
        uuid: string;
    }

    export interface GetPortalsPortal {
        /**
         * Space-delimited list of IP addresses (in CIDR notation) allowed to invoke this portal.
         */
        allowedIpAddresses: string;
        /**
         * The time when the portal was created.
         */
        createdAt: string;
        /**
         * Information about the user who created the portal.
         */
        createdBy: outputs.Organization.GetPortalsPortalCreatedBy;
        /**
         * The description of the portal.
         */
        description: string;
        /**
         * The name of the portal.
         */
        name: string;
        /**
         * The GraphQL query that the portal executes.
         */
        query: string;
        /**
         * The slug of the portal.
         */
        slug: string;
        /**
         * Whether users can invoke the portal.
         */
        userInvokable: boolean;
        /**
         * The UUID of the portal.
         */
        uuid: string;
    }

    export interface GetPortalsPortalCreatedBy {
        /**
         * The email of the user.
         */
        email: string;
        /**
         * The name of the user.
         */
        name: string;
        /**
         * The UUID of the user.
         */
        uuid: string;
    }

    export interface PortalCreatedBy {
        /**
         * The email of the user.
         */
        email: string;
        /**
         * The name of the user.
         */
        name: string;
        /**
         * The UUID of the user.
         */
        uuid: string;
    }

}

export namespace Pipeline {
    export interface PipelineProviderSettings {
        /**
         * Whether to create builds when branches are pushed.
         */
        buildBranches: boolean;
        /**
         * Whether to create merge queue builds for a merge queue enabled GitHub repository with required status checks
         */
        buildMergeGroupChecksRequested: boolean;
        /**
         * Whether to create builds for pull requests when its base branch changes.
         */
        buildPullRequestBaseBranchChanged: boolean;
        /**
         * Whether to create builds for pull requests from third-party forks.
         */
        buildPullRequestForks: boolean;
        /**
         * Whether to create builds for pull requests when labels are added or removed.
         */
        buildPullRequestLabelsChanged: boolean;
        /**
         * Whether to create a build when a pull request changes to "Ready for review".
         */
        buildPullRequestReadyForReview: boolean;
        /**
         * Whether to create builds for commits that are part of a pull request.
         */
        buildPullRequests: boolean;
        /**
         * Whether to create builds when tags are pushed.
         */
        buildTags: boolean;
        /**
         * Automatically cancel running builds for a branch if the branch is deleted.
         */
        cancelDeletedBranchBuilds: boolean;
        /**
         * Whether to cancel any running builds belonging to a removed merge group.
         */
        cancelWhenMergeGroupDestroyed: boolean;
        /**
         * The condition to evaluate when deciding if a build should run. This is only valid when `triggerMode` is `code`. More details available in [the documentation](https://buildkite.com/docs/pipelines/conditionals).
         */
        filterCondition: string;
        /**
         * Whether to filter builds to only run when the condition in `filterCondition` is true.
         */
        filterEnabled: boolean;
        /**
         * Whether to prevent caching pull requests with the source branch matching the default branch.
         */
        ignoreDefaultBranchPullRequests: boolean;
        /**
         * Prefix branch names for third-party fork builds to ensure they don't trigger branch conditions. For example, the main branch from some-user will become some-user:main.
         */
        prefixPullRequestForkBranchNames: boolean;
        /**
         * The status to use for blocked builds. Pending can be used with [required status checks](https://help.github.com/en/articles/enabling-required-status-checks) to prevent merging pull requests with blocked builds.
         */
        publishBlockedAsPending: boolean;
        /**
         * Whether to update the status of commits in Bitbucket, GitHub, or GitLab.
         */
        publishCommitStatus: boolean;
        /**
         * Whether to create a separate status for each job in a build, allowing you to see the status of each job directly in Bitbucket or GitHub.
         */
        publishCommitStatusPerStep: boolean;
        /**
         * Filter pull requests builds by the branch filter.
         */
        pullRequestBranchFilterConfiguration: string;
        /**
         * Filter pull request builds.
         */
        pullRequestBranchFilterEnabled: boolean;
        /**
         * Whether to create a separate status for pull request builds, allowing you to require a passing pull request build in your [required status checks](https://help.github.com/en/articles/enabling-required-status-checks) in GitHub.
         */
        separatePullRequestStatuses: boolean;
        /**
         * Whether to skip creating a new build if an existing build for the commit and branch already exists. This option is only valid if the pipeline uses a GitHub repository.
         */
        skipBuildsForExistingCommits: boolean;
        /**
         * Whether to skip creating a new build for a pull request if an existing build for the commit and branch already exists.
         */
        skipPullRequestBuildsForExistingCommits: boolean;
        /**
         * What type of event to trigger builds on. Must be one of:
         * 	- `code` will create builds when code is pushed to GitHub.
         * 	- `deployment` will create builds when a deployment is created in GitHub.
         * 	- `fork` will create builds when the GitHub repository is forked.
         * 	- `none` will not create any builds based on GitHub activity.
         *
         * 	> `triggerMode` is only valid if the pipeline uses a GitHub repository.
         * 	> If not set, the default value is `code` and other provider settings defaults are applied.
         */
        triggerMode: string;
        /**
         * When enabled, agents performing a git diff to determine steps to upload based on [`ifChanged`](https://buildkite.com/docs/pipelines/configure/step-types/command-step#agent-applied-attributes)comparisons will use the base commit that points to the previous merge group rather than the base branch
         */
        useMergeGroupBaseCommitForGitDiffBase: boolean;
    }

}

export namespace Team {
    export interface GetTeamsTeam {
        /**
         * The default member role for new team members.
         */
        defaultMemberRole: string;
        /**
         * The description of the team.
         */
        description: string;
        /**
         * The GraphQL ID of the team.
         */
        id: string;
        /**
         * Whether this is the default team for the organization.
         */
        isDefaultTeam: boolean;
        /**
         * Whether team members can create pipelines.
         */
        membersCanCreatePipelines: boolean;
        /**
         * Whether team members can create registries.
         */
        membersCanCreateRegistries: boolean;
        /**
         * Whether team members can create test suites.
         */
        membersCanCreateSuites: boolean;
        /**
         * Whether team members can destroy packages.
         */
        membersCanDestroyPackages: boolean;
        /**
         * Whether team members can destroy registries.
         */
        membersCanDestroyRegistries: boolean;
        /**
         * The name of the team.
         */
        name: string;
        /**
         * The privacy setting of the team.
         */
        privacy: string;
        /**
         * The slug of the team.
         */
        slug: string;
        /**
         * The UUID of the team.
         */
        uuid: string;
    }

}

export namespace config {
    export interface Timeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
         */
        read?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }

}
